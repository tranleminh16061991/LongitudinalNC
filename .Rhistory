digits = all_continuous() ~ 2,
missing_text = "(Missing)"
) %>%
add_p(
test = list(
all_continuous() ~ "t.test",
all_categorical() ~ "chisq.test"
),
test.args = all_tests("t.test") ~ list(var.equal = FALSE)  # Welch's t-test
) %>%
bold_labels() %>%
bold_p(0.05)
# 5) Xuất bảng
tbl_summary_obj %>% as_flex_table()
library(dplyr)
library(gtsummary)
library(readr)
# Clean numeric
clean_numeric <- function(x) {
if (is.numeric(x)) return(x)
x <- as.character(x)
x <- trimws(x)
x[x == ""] <- NA
suppressWarnings(readr::parse_number(x))
}
bioimpedance_vars <- c(
"bmi", "ac", "whr", "pbcm", "pbf", "bmr", "tbw_ffm",
"ecw_tcw", "ECW_ICW_upper", "ECW_ICW_lower",
"Water_Lean_upper", "Water_Lean_lower",
"R_upper", "R_lower", "Xc_upper", "Xc_lower",
"PA_upper", "PA_lower"
)
# 1) Lấy baseline: dòng đầu tiên theo thời gian cho mỗi USUBJID
df_baseline_bia <- df_long.analysis %>%
group_by(USUBJID) %>%
arrange(datetest, .by_group = TRUE) %>%
slice_head(n = 1) %>%
ungroup() %>%
filter(Change_Type %in% c("StableCN", "ProgressiveCN")) %>%
# 2) CHỈ giữ Change_Type và các biến bioimpedance
select(Change_Type, all_of(bioimpedance_vars)) %>%
# 3) Làm sạch và chuyển đổi sang numeric
mutate(across(-Change_Type, clean_numeric))
# 4) Tạo Table với t-test chỉ cho các biến bioimpedance
tbl_bia_comparison <- df_baseline_bia %>%
tbl_summary(
by = Change_Type,
type = all_continuous() ~ "continuous",
statistic = all_continuous() ~ "{mean} ({sd})",
digits = all_continuous() ~ 2,
missing_text = "(Missing)"
) %>%
add_p(
test = all_continuous() ~ "t.test",
test.args = list(var.equal = FALSE)  # Welch's t-test
) %>%
bold_labels() %>%
bold_p(0.05)
# 5) Hiển thị bảng
tbl_bia_comparison
# 6) Xuất bảng dưới dạng flextable
ft_bia <- tbl_bia_comparison %>% as_flex_table()
ft_bia
library(dplyr)
library(lubridate)
library(broom)
df_long.analysis <- df_overall %>%
drop_na() %>%
mutate(datetest = mdy(datetest)) %>%              # Định dạng ngày
group_by(USUBJID) %>%
arrange(datetest) %>%                             # Sắp xếp theo ngày trong từng người
mutate(
baseline_date = min(datetest, na.rm = TRUE),    # Lấy ngày đầu tiên của từng người
elapsed_years = as.numeric(difftime(datetest, baseline_date, units="days")) / 365.25
) %>%
select(-baseline_date) %>%
ungroup()
# Kiểm tra biến elapsed_years
summary(df_long.analysis$elapsed_years)
head(df_long.analysis[, c("datetest","USUBJID","elapsed_years")], 200)
# Check initial structure of variables
str(df_long.analysis[, c("AGE", "gds", "kdsq", "sysbp", "diabp", "bmr", "MMSE")])
# Convert specified variables to numeric (handling factors if any)
vars_to_convert <- c("AGE", "gds", "kdsq", "sysbp", "diabp", "bmr", "MMSE")
df_long.analysis <- df_long.analysis %>%
mutate(across(all_of(vars_to_convert), ~ as.numeric(as.character(.))))
# Check structure after conversion
str(df_long.analysis[, vars_to_convert])
# Optional: summary statistics to verify numeric conversion
summary(df_long.analysis[, vars_to_convert])
#df_demo <- df.long_multi %>% select( Group, SEX:EDUYR, MMSE,AGE)
view(dfSummary(df_long.analysis ))
# List of continuous variables to test (same as Table 1)
cont_vars <- c("AGE", "gds", "kdsq", "sysbp", "diabp", "bmr", "MMSE",
"SNSB_attention", "SNSB_memory", "SNSB_language", "SNSB_visuospatial", "SNSB_frontal")
# Function to run Shapiro-Wilk on each variable by Change_Type
normality_results <- df_long.analysis.baseline %>%
select(Change_Type, all_of(cont_vars)) %>%
pivot_longer(cols = -Change_Type, names_to = "Variable", values_to = "Value") %>%
group_by(Change_Type, Variable) %>%
summarize(
n = sum(!is.na(Value)),
Shapiro_W_pvalue = if(n >= 3) shapiro.test(Value)$p.value else NA_real_
) %>%
mutate(Normality = ifelse(Shapiro_W_pvalue > 0.05, "normal", "non-normal"))
library(dplyr)
library(lubridate)
df_long.analysis <- df_overall %>%
drop_na() %>%
mutate(datetest = mdy(datetest)) %>%              # Định dạng ngày
group_by(USUBJID) %>%
arrange(datetest) %>%                             # Sắp xếp theo ngày trong từng người
mutate(
baseline_date = min(datetest, na.rm = TRUE),    # Lấy ngày đầu tiên của từng người
elapsed_years = as.numeric(difftime(datetest, baseline_date, units="days")) / 365.25
) %>%
select(-baseline_date) %>%
ungroup()
# Kiểm tra biến elapsed_years
summary(df_long.analysis$elapsed_years)
head(df_long.analysis[, c("datetest","USUBJID","elapsed_years")], 200)
# Check initial structure of variables
str(df_long.analysis[, c("AGE", "gds", "kdsq", "sysbp", "diabp", "bmr", "MMSE")])
# Convert specified variables to numeric (handling factors if any)
vars_to_convert <- c("AGE", "gds", "kdsq", "sysbp", "diabp", "bmr", "MMSE")
df_long.analysis <- df_long.analysis %>%
mutate(across(all_of(vars_to_convert), ~ as.numeric(as.character(.))))
# Check structure after conversion
str(df_long.analysis[, vars_to_convert])
# Optional: summary statistics to verify numeric conversion
summary(df_long.analysis[, vars_to_convert])
#df_demo <- df.long_multi %>% select( Group, SEX:EDUYR, MMSE,AGE)
view(dfSummary(df_long.analysis ))
library(dplyr)
library(gtsummary)
library(readr)
# Clean numeric
clean_numeric <- function(x) {
if (is.numeric(x)) return(x)
x <- as.character(x)
x <- trimws(x)
x[x == ""] <- NA
suppressWarnings(readr::parse_number(x))
}
bioimpedance_vars <- c(
"bmi", "ac", "whr", "pbcm", "pbf", "bmr", "tbw_ffm",
"ecw_tcw", "ECW_ICW_upper", "ECW_ICW_lower",
"Water_Lean_upper", "Water_Lean_lower",
"R_upper", "R_lower", "Xc_upper", "Xc_lower",
"PA_upper", "PA_lower"
)
# 1) Lấy baseline: dòng đầu tiên theo thời gian cho mỗi USUBJID
df_baseline_bia <- df_long.analysis %>%
group_by(USUBJID) %>%
arrange(datetest, .by_group = TRUE) %>%
slice_head(n = 1) %>%
ungroup() %>%
filter(Change_Type %in% c("StableCN", "ProgressiveCN")) %>%
# 2) CHỈ giữ Change_Type và các biến bioimpedance
select(Change_Type, all_of(bioimpedance_vars)) %>%
# 3) Làm sạch và chuyển đổi sang numeric
mutate(across(-Change_Type, clean_numeric))
all_continuous_vars <- c(
"AGE", "gds", "kdsq", "sysbp", "diabp", "bmr", "MMSE",
"SNSB_attention", "SNSB_memory", "SNSB_language", "SNSB_visuospatial", "SNSB_frontal",
"bmi", "ac", "whr", "pbcm", "pbf", "tbw_ffm",
"ecw_tcw", "ECW_ICW_upper", "ECW_ICW_lower",
"Water_Lean_upper", "Water_Lean_lower",
"R_upper", "R_lower", "Xc_upper", "Xc_lower",
"PA_upper", "PA_lower"
)
library(dplyr)
library(broom)
library(tidyr)
normality_results <- df_long.analysis.baseline %>%
select(Change_Type, all_of(all_continuous_vars)) %>%
pivot_longer(cols = -Change_Type, names_to = "Variable", values_to = "Value") %>%
group_by(Change_Type, Variable) %>%
summarize(
n = sum(!is.na(Value)),
Shapiro_W_pvalue = if(n >= 3) shapiro.test(Value)$p.value else NA_real_
) %>%
mutate(Normality = ifelse(Shapiro_W_pvalue > 0.05, "normal", "non-normal"))
library(dplyr)
library(gtsummary)
library(readr)
library(broom)
library(tidyr)
# Clean numeric
clean_numeric <- function(x) {
if (is.numeric(x)) return(x)
x <- as.character(x)
x <- trimws(x)
x[x == ""] <- NA
suppressWarnings(readr::parse_number(x))
}
bioimpedance_vars <- c(
"bmi", "ac", "whr", "pbcm", "pbf", "bmr", "tbw_ffm",
"ecw_tcw", "ECW_ICW_upper", "ECW_ICW_lower",
"Water_Lean_upper", "Water_Lean_lower",
"R_upper", "R_lower", "Xc_upper", "Xc_lower",
"PA_upper", "PA_lower"
)
# 1) Lấy baseline: dòng đầu tiên theo thời gian cho mỗi USUBJID
df_baseline_bia <- df_long.analysis %>%
group_by(USUBJID) %>%
arrange(datetest, .by_group = TRUE) %>%
slice_head(n = 1) %>%
ungroup() %>%
filter(Change_Type %in% c("StableCN", "ProgressiveCN")) %>%
# 2) CHỈ giữ Change_Type và các biến bioimpedance
select(Change_Type, all_of(bioimpedance_vars)) %>%
# 3) Làm sạch và chuyển đổi sang numeric
mutate(across(-Change_Type, clean_numeric))
all_continuous_vars <- c(
"AGE", "gds", "kdsq", "sysbp", "diabp", "bmr", "MMSE",
"SNSB_attention", "SNSB_memory", "SNSB_language", "SNSB_visuospatial", "SNSB_frontal",
"bmi", "ac", "whr", "pbcm", "pbf", "tbw_ffm",
"ecw_tcw", "ECW_ICW_upper", "ECW_ICW_lower",
"Water_Lean_upper", "Water_Lean_lower",
"R_upper", "R_lower", "Xc_upper", "Xc_lower",
"PA_upper", "PA_lower"
)
normality_results <- df_long.analysis.baseline %>%
select(Change_Type, all_of(all_continuous_vars)) %>%
pivot_longer(cols = -Change_Type, names_to = "Variable", values_to = "Value") %>%
group_by(Change_Type, Variable) %>%
summarize(
n = sum(!is.na(Value)),
Shapiro_W_pvalue = if(n >= 3) shapiro.test(Value)$p.value else NA_real_
) %>%
mutate(Normality = ifelse(Shapiro_W_pvalue > 0.05, "normal", "non-normal"))
library(ggplot2)
library(tidyr)
library(dplyr)
library(ggpubr)
library(gtsummary)
library(flextable)
library(tidyverse)
library(rstatix)
library(ggpubr)
library(summarytools)
library(cowplot)
library(patchwork)
# --- LOAD AT START OF SESSION ---
library(lmerTest)
library(broom.mixed)
library(emmeans)
library(stringr)
#library(lme4)
library(sjPlot)
# Read your data ( KIOM_USER or admin )
setwd("C:/Users/KIOM_USER/Documents/GitHub/LongitudinalNC")
df <- read.csv("Longitudinal_BIA_StableNCvsProgressiveNC.csv",
header = TRUE, stringsAsFactors = FALSE, na.strings = c("", "NA"))
df$COGNITIVESTAT <- df$COGNITIVESTAT %>%
str_replace_all("\\.", "")   %>%      # Remove all dots
str_trim(side = "both")       # Remove leading/trailing spaces
df <- df %>% add_count(USUBJID, name = "visit_count")
view(dfSummary(df ))
#get Empty COGNIVESTATE per year
#In the subsequent analysis
df %>%
group_by(year) %>%
summarise(empty_or_na_COGNIVESTATE = sum(is.na(COGNITIVESTAT) | COGNITIVESTAT == "")) %>%
print()
# Read your data ( KIOM_USER or admin )
setwd("C:/Users/KIOM_USER/Documents/GitHub/LongitudinalNC")
df <- read.csv("Longitudinal_BIA_StableNCvsProgressiveNC.csv",
header = TRUE, stringsAsFactors = FALSE, na.strings = c("", "NA"))
df$COGNITIVESTAT <- df$COGNITIVESTAT %>%
str_replace_all("\\.", "")   %>%      # Remove all dots
str_trim(side = "both")       # Remove leading/trailing spaces
df <- df %>% add_count(USUBJID, name = "visit_count")
view(dfSummary(df ))
#get Empty COGNIVESTATE per year
#In the subsequent analysis
df %>%
group_by(year) %>%
summarise(empty_or_na_COGNIVESTATE = sum(is.na(COGNITIVESTAT) | COGNITIVESTAT == "")) %>%
print()
df.long <- df %>%
# filter(Group %in% c("CN", "MCI", "AD"), year %in% 2019:2024, r_squared >= 0.95) %>%
filter(Group %in% c("CN", "MCI", "AD"), year %in% 2019:2024) %>%
filter(!is.na(COGNITIVESTAT) & COGNITIVESTAT != "") %>% # drop NA or empty
filter(!COGNITIVESTAT %in% c("aMCI,Dep")) %>%
drop_na() %>%
add_count(USUBJID, name = "visit_count") %>%
mutate(
# Treat SMI as CN
COGNITIVESTAT = ifelse(COGNITIVESTAT == "SMI", "CN", COGNITIVESTAT)
)
# Keep only subjects with at least 2 valid records
df.long_multi <- df.long %>%
group_by(USUBJID) %>%
filter(n() >= 2) %>%
ungroup()
(df_changes <- df.long_multi %>%
arrange(USUBJID, year) %>%  # ensure chronological order
group_by(USUBJID) %>%
summarise(
#Status_Changed = n_distinct(COGNITIVESTAT, na.rm = TRUE) > 1,
Transitions = paste(COGNITIVESTAT, collapse = " -> ")
))
(df_summary <- df_changes %>%
group_by(Transitions) %>%
summarise(Count = n()) %>%
mutate( Percentage = round(Count / sum(Count) * 100, 1)) %>%
arrange(desc(Count)))
#df_demo <- df.long_multi %>% select( Group, SEX:EDUYR, MMSE,AGE)
view(dfSummary(df.long_multi ))
#ONly take note of inital and final transitions
df_overall <- df.long_multi %>%
mutate(
COGNITIVESTAT = case_when(
COGNITIVESTAT %in% c("aMCI", "naMCI") ~ "MCI",
COGNITIVESTAT == "SMI" ~ "CN",
TRUE ~ COGNITIVESTAT
)
) %>%
arrange(USUBJID, year) %>%
group_by(USUBJID) %>%
mutate(
Initial_Status = first(COGNITIVESTAT),
Final_Status   = last(COGNITIVESTAT)
) %>%
mutate(
Transition = paste(Initial_Status, "->", Final_Status),
Change_Type = case_when(
Initial_Status == "CN" & Final_Status == "CN" ~ "StableCN",
Initial_Status == "CN" & Final_Status == "MCI" ~ "ProgressiveCN",
TRUE ~ NA_character_
)
) %>%
ungroup()
view(dfSummary(df_overall ))
(df_transition_summary <- df_overall %>%
group_by(Transition) %>%
summarise(
Count = n(),
.groups = "drop"
) %>%
mutate(
Percentage = round(Count / sum(Count) * 100, 1)
) %>%
arrange(desc(Count)))
#get Unique Particpants for analysis
df_unique_transitions <- df_overall %>%
select(USUBJID, Transition, Change_Type) %>%  # keep only relevant columns
distinct()  # keep only unique rows by ID, Transition, Change_Type
(df_summary <- df_unique_transitions %>%
group_by(Transition, Change_Type) %>%
summarise(
Count = n(),
.groups = "drop"
) %>%
mutate(
Percentage = round(Count / sum(Count) * 100, 1)
) %>%
arrange(desc(Count)))
df_long.analysis <- df_overall  %>%  drop_na() %>% mutate_if(is.character, as.factor) %>%   droplevels() %>%
add_count(USUBJID, name = "visit_count") #%>% filter(Transition != "CN -> CN")
# Relevel Change_Type with "Stable" as reference
df_long.analysis$Change_Type <- relevel(factor(df_long.analysis$Change_Type), ref = "StableCN")
view(dfSummary(df_long.analysis ))
#get Unique Particpants for analysis
df_unique_transitions <- df_long.analysis %>%
select(USUBJID, Transition, Change_Type) %>%  # keep only relevant columns
distinct()  # keep only unique rows by ID, Transition, Change_Type
(df_summary <- df_unique_transitions %>%
group_by(Transition, Change_Type) %>%
summarise(
Count = n(),
.groups = "drop"
) %>%
mutate(
Percentage = round(Count / sum(Count) * 100, 1)
) %>%
arrange(desc(Count)))
#df_demo <- df.long_multi %>% select( Group, SEX:EDUYR, MMSE,AGE)
view(dfSummary(df.long_multi ))
library(dplyr)
library(lubridate)
df_long.analysis <- df_overall %>%
drop_na() %>%
mutate(datetest = mdy(datetest)) %>%              # Định dạng ngày
group_by(USUBJID) %>%
arrange(datetest) %>%                             # Sắp xếp theo ngày trong từng người
mutate(
baseline_date = min(datetest, na.rm = TRUE),    # Lấy ngày đầu tiên của từng người
elapsed_years = as.numeric(difftime(datetest, baseline_date, units="days")) / 365.25
) %>%
select(-baseline_date) %>%
ungroup()
# Kiểm tra biến elapsed_years
summary(df_long.analysis$elapsed_years)
head(df_long.analysis[, c("datetest","USUBJID","elapsed_years")], 200)
# Check initial structure of variables
str(df_long.analysis[, c("AGE", "gds", "kdsq", "sysbp", "diabp", "bmr", "MMSE")])
# Convert specified variables to numeric (handling factors if any)
vars_to_convert <- c("AGE", "gds", "kdsq", "sysbp", "diabp", "bmr", "MMSE")
df_long.analysis <- df_long.analysis %>%
mutate(across(all_of(vars_to_convert), ~ as.numeric(as.character(.))))
# Check structure after conversion
str(df_long.analysis[, vars_to_convert])
# Optional: summary statistics to verify numeric conversion
summary(df_long.analysis[, vars_to_convert])
#df_demo <- df.long_multi %>% select( Group, SEX:EDUYR, MMSE,AGE)
view(dfSummary(df_long.analysis ))
library(dplyr)
library(gtsummary)
library(readr)   # parse_number để làm sạch numeric an toàn
# Hàm làm sạch numeric an toàn
clean_numeric <- function(x) {
if (is.numeric(x)) return(x)
x <- as.character(x)
x <- trimws(x)
x[x == ""] <- NA
suppressWarnings(readr::parse_number(x))
}
# 1) Lấy baseline: dòng đầu tiên theo thời gian cho mỗi USUBJID
df_long.analysis.baseline <- df_long.analysis %>%
group_by(USUBJID) %>%
arrange(datetest, .by_group = TRUE) %>%   # sắp xếp theo ngày khám trong từng người
slice_head(n = 1) %>%                     # lấy đúng 1 dòng baseline/đối tượng
ungroup() %>%
filter(Change_Type %in% c("StableCN", "ProgressiveCN")) %>%
# 2) Chỉ giữ các biến yêu cầu cho Table 1 (không đưa cột Date vào)
select(
Change_Type,
AGE:EDUYR,
gds, kdsq, sysbp, diabp, visit_count, MMSE,
SNSB_attention:SNSB_frontal
) %>%
# 3) Chuẩn hóa kiểu dữ liệu: chỉ các cột khác Change_Type được làm sạch numeric
mutate(across(-Change_Type, clean_numeric))
# (tuỳ chọn) xác nhận MMSE là numeric
stopifnot(is.numeric(df_long.analysis.baseline$MMSE))
# 4) Tạo Table 1: hiển thị mean (sd) cho biến liên tục, ép MMSE là continuous
tbl_summary_obj <- df_long.analysis.baseline %>%
tbl_summary(
by = Change_Type,
type = list(
MMSE ~ "continuous"                 # đảm bảo MMSE hiển thị như biến liên tục
),
statistic = list(
all_continuous() ~ "{mean} ({sd})",
all_categorical() ~ "{n} / {N} ({p}%)"
),
digits = all_continuous() ~ 2,
missing_text = "(Missing)"
) %>%
add_p(
test = list(
all_continuous() ~ "t.test",
all_categorical() ~ "chisq.test"
),
test.args = all_tests("t.test") ~ list(var.equal = FALSE)  # Welch's t-test
) %>%
bold_labels() %>%
bold_p(0.05)
# 5) Xuất bảng
tbl_summary_obj %>% as_flex_table()
library(dplyr)
library(gtsummary)
library(readr)
# Clean numeric
clean_numeric <- function(x) {
if (is.numeric(x)) return(x)
x <- as.character(x)
x <- trimws(x)
x[x == ""] <- NA
suppressWarnings(readr::parse_number(x))
}
bioimpedance_vars <- c(
"bmi", "ac", "whr", "pbcm", "pbf", "bmr", "tbw_ffm",
"ecw_tcw", "ECW_ICW_upper", "ECW_ICW_lower",
"Water_Lean_upper", "Water_Lean_lower",
"R_upper", "R_lower", "Xc_upper", "Xc_lower",
"PA_upper", "PA_lower"
)
# 1) Lấy baseline: dòng đầu tiên theo thời gian cho mỗi USUBJID
df_baseline_bia <- df_long.analysis %>%
group_by(USUBJID) %>%
arrange(datetest, .by_group = TRUE) %>%
slice_head(n = 1) %>%
ungroup() %>%
filter(Change_Type %in% c("StableCN", "ProgressiveCN")) %>%
# 2) CHỈ giữ Change_Type và các biến bioimpedance
select(Change_Type, all_of(bioimpedance_vars)) %>%
# 3) Làm sạch và chuyển đổi sang numeric
mutate(across(-Change_Type, clean_numeric))
# 4) Tạo Table với t-test chỉ cho các biến bioimpedance
tbl_bia_comparison <- df_baseline_bia %>%
tbl_summary(
by = Change_Type,
type = all_continuous() ~ "continuous",
statistic = all_continuous() ~ "{mean} ({sd})",
digits = all_continuous() ~ 2,
missing_text = "(Missing)"
) %>%
add_p(
test = all_continuous() ~ "t.test",
test.args = list(var.equal = FALSE)  # Welch's t-test
) %>%
bold_labels() %>%
bold_p(0.05)
# 5) Hiển thị bảng
tbl_bia_comparison
# 6) Xuất bảng dưới dạng flextable
ft_bia <- tbl_bia_comparison %>% as_flex_table()
ft_bia
