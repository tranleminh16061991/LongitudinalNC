bold_labels() %>%
bold_p(t = 0.05)
tbl_all %>% as_flex_table() %>% print()
}
# List of variables to test
vars_bia <- c("bmi", "ac", "whr", "pbcm", "pbf", "bmr", "tbw_ffm", "ecw_tcw",
"ECW_ICW_upper", "ECW_ICW_lower", "Water_Lean_upper", "Water_Lean_lower",
"R_upper", "R_lower", "Xc_upper", "Xc_lower", "PA_upper", "PA_lower")
# Clean numeric variables before testing
df_long.analysis.baseline <- df_long.analysis.baseline %>%
mutate(across(all_of(vars_bia), clean_numeric))
# Function to perform individual t-test and extract tidy results
library(broom)
t_test_results <- lapply(vars_bia, function(var) {
formula <- as.formula(paste(var, "~ Change_Type"))
ttest <- t.test(formula, data = df_long.analysis.baseline, var.equal = FALSE)
broom::tidy(ttest) %>% mutate(Variable = var)
})
# Combine all results into one data frame
t_test_summary <- do.call(rbind, t_test_results)
# Reorder columns for readability
t_test_summary <- t_test_summary[, c("Variable", "estimate1", "estimate2", "statistic", "parameter", "p.value", "conf.low", "conf.high")]
# Display the summary table with key statistics for each variable
print(t_test_summary)
library(dplyr)
library(gtsummary)
library(readr)
# Define variables of interest for baseline comparison
variables_baseline <- c(
"bmi", "ac", "whr", "pbcm", "pbf", "bmr", "tbw_ffm",
"ecw_tcw", "ECW_ICW_upper", "ECW_ICW_lower", "Water_Lean_upper",
"Water_Lean_lower", "R_upper", "R_lower", "Xc_upper", "Xc_lower",
"PA_upper", "PA_lower",
"AGE", "gds", "kdsq", "sysbp", "diabp", "visit_count", "MMSE",
)
library(dplyr)
library(gtsummary)
library(readr)
# Define variables of interest for baseline comparison
variables_baseline <- c(
"bmi", "ac", "whr", "pbcm", "pbf", "bmr", "tbw_ffm",
"ecw_tcw", "ECW_ICW_upper", "ECW_ICW_lower", "Water_Lean_upper",
"Water_Lean_lower", "R_upper", "R_lower", "Xc_upper", "Xc_lower",
"PA_upper", "PA_lower",
"AGE", "gds", "kdsq", "sysbp", "diabp", "visit_count", "MMSE",
)
library(dplyr)
library(gtsummary)
library(readr)
# Define variables of interest for baseline comparison
variables_baseline <- c(
"bmi", "ac", "whr", "pbcm", "pbf", "bmr", "tbw_ffm",
"ecw_tcw", "ECW_ICW_upper", "ECW_ICW_lower", "Water_Lean_upper",
"Water_Lean_lower", "R_upper", "R_lower", "Xc_upper", "Xc_lower",
"PA_upper", "PA_lower",
"AGE", "gds", "kdsq", "sysbp", "diabp", "visit_count", "MMSE",
)
library(dplyr)
library(gtsummary)
library(readr)
# Define variables of interest for baseline comparison
variables_baseline <- c(
"bmi", "ac", "whr", "pbcm", "pbf", "bmr", "tbw_ffm",
"ecw_tcw", "ECW_ICW_upper", "ECW_ICW_lower", "Water_Lean_upper",
"Water_Lean_lower", "R_upper", "R_lower", "Xc_upper", "Xc_lower",
"PA_upper", "PA_lower",
"AGE", "gds", "kdsq", "sysbp", "diabp", "visit_count", "MMSE",
)
library(dplyr)
library(gtsummary)
library(readr)
# Define variables of interest for baseline comparison
variables_baseline <- c(
"bmi", "ac", "whr", "pbcm", "pbf", "bmr", "tbw_ffm",
"ecw_tcw", "ECW_ICW_upper", "ECW_ICW_lower", "Water_Lean_upper",
"Water_Lean_lower", "R_upper", "R_lower", "Xc_upper", "Xc_lower",
"PA_upper", "PA_lower",
"AGE", "gds", "kdsq", "sysbp", "diabp", "visit_count", "MMSE",
# Add SNSB cognitive domains as needed, e.g.:
"SNSB_attention", "SNSB_frontal"
)
# Extract baseline data (assuming df_long.analysis.baseline from your previous steps)
df_baseline_for_ttest <- df_long.analysis.baseline %>%
select(Change_Type, all_of(variables_baseline)) %>%
mutate(across(-Change_Type, clean_numeric))  # ensure numeric cleaning
# Perform summary table with t-tests by Change_Type
tbl_ttest_results <- df_baseline_for_ttest %>%
tbl_summary(
by = Change_Type,
type = all_continuous() ~ "continuous",
statistic = all_continuous() ~ "{mean} ({sd})",
digits = all_continuous() ~ 2,
missing_text = "(Missing)"
) %>%
add_p(
test = all_continuous() ~ "t.test",
test.args = list(var.equal = FALSE)  # Welch's t-test
) %>%
bold_labels() %>%
bold_p(0.05)
# View the table
tbl_ttest_results
# Export as flextable if desired:
ft <- tbl_ttest_results %>% as_flex_table()
ft
library(dplyr)
library(gtsummary)
library(readr)
# Clean numeric
clean_numeric <- function(x) {
if (is.numeric(x)) return(x)
x <- as.character(x)
x <- trimws(x)
x[x == ""] <- NA
suppressWarnings(readr::parse_number(x))
}
bioimpedance_vars <- c(
"bmi", "ac", "whr", "pbcm", "pbf", "bmr", "tbw_ffm",
"ecw_tcw", "ECW_ICW_upper", "ECW_ICW_lower",
"Water_Lean_upper", "Water_Lean_lower",
"R_upper", "R_lower", "Xc_upper", "Xc_lower",
"PA_upper", "PA_lower"
)
# 1) Lấy baseline: dòng đầu tiên theo thời gian cho mỗi USUBJID
df_baseline_bia <- df_long.analysis %>%
group_by(USUBJID) %>%
arrange(datetest, .by_group = TRUE) %>%
slice_head(n = 1) %>%
ungroup() %>%
filter(Change_Type %in% c("StableCN", "ProgressiveCN")) %>%
# 2) CHỈ giữ Change_Type và các biến bioimpedance
select(Change_Type, all_of(bioimpedance_vars)) %>%
# 3) Làm sạch và chuyển đổi sang numeric
mutate(across(-Change_Type, clean_numeric))
# 4) Tạo Table với t-test chỉ cho các biến bioimpedance
tbl_bia_comparison <- df_baseline_bia %>%
tbl_summary(
by = Change_Type,
type = all_continuous() ~ "continuous",
statistic = all_continuous() ~ "{mean} ({sd})",
digits = all_continuous() ~ 2,
missing_text = "(Missing)"
) %>%
add_p(
test = all_continuous() ~ "t.test",
test.args = list(var.equal = FALSE)  # Welch's t-test
) %>%
bold_labels() %>%
bold_p(0.05)
# 5) Hiển thị bảng
tbl_bia_comparison
# 6) Xuất bảng dưới dạng flextable
ft_bia <- tbl_bia_comparison %>% as_flex_table()
ft_bia
library(dplyr)
library(gtsummary)
library(readr)   # parse_number để làm sạch numeric an toàn
# Hàm làm sạch numeric an toàn
clean_numeric <- function(x) {
if (is.numeric(x)) return(x)
x <- as.character(x)
x <- trimws(x)
x[x == ""] <- NA
suppressWarnings(readr::parse_number(x))
}
# Packages
library(dplyr)
library(tidyr)
library(rstatix)   # shapiro_test, wilcox_test helpers
library(ggpubr)    # qq plot
# 1) Chọn biến cần kiểm tra ở Table 1
vars_tbl1 <- c("AGE","gds","kdsq","sysbp","diabp","bmr","MMSE")
# 2) Shapiro–Wilk theo nhóm cho Table 1
shapiro_tbl1 <- df_long.analysis.baseline %>%
select(Change_Type, all_of(vars_tbl1)) %>%
pivot_longer(-Change_Type, names_to = "variable", values_to = "value") %>%
group_by(Change_Type, variable) %>%
shapiro_test(value) %>%      # trả về W và p
ungroup()
# ============================
# 0) Libraries & helpers
# ============================
# Normality checks (Shapiro), Q-Q plots, summary tables, export
library(dplyr)
library(tidyr)
library(purrr)
library(readr)
library(rstatix)     # shapiro_test
library(ggpubr)      # ggqqplot
library(gtsummary)   # tbl_summary + add_p
library(flextable)   # as_flex_table
library(officer)     # save_as_docx
library(stringr)
# Helper: clean numeric safely from character/factor
clean_numeric <- function(x) {
if (is.numeric(x)) return(x)
x <- as.character(x)
x <- trimws(x)
x[x == ""] <- NA
suppressWarnings(readr::parse_number(x))
}
# Assert data existence (df_long.analysis built earlier in your pipeline)
stopifnot(exists("df_long.analysis"))
# ============================
# 1) Build baseline datasets
# ============================
# Table 1 variables (clinical/psychometric)
vars_tbl1 <- c("AGE","gds","kdsq","sysbp","diabp","bmr","MMSE","EDUYR")
df_long.analysis.baseline <- df_long.analysis %>%
group_by(USUBJID) %>%
arrange(datetest, .by_group = TRUE) %>%
slice_head(n = 1) %>%
ungroup() %>%
filter(Change_Type %in% c("StableCN","ProgressiveCN")) %>%
select(Change_Type, all_of(vars_tbl1)) %>%
mutate(across(-Change_Type, clean_numeric))
stopifnot(is.numeric(df_long.analysis.baseline$MMSE))
# Bioimpedance variables
bioimpedance_vars <- c(
"bmi","ac","whr","pbcm","pbf","bmr","tbw_ffm",
"ecw_tcw","ECW_ICW_upper","ECW_ICW_lower",
"Water_Lean_upper","Water_Lean_lower",
"R_upper","R_lower","Xc_upper","Xc_lower",
"PA_upper","PA_lower"
)
df_baseline_bia <- df_long.analysis %>%
group_by(USUBJID) %>%
arrange(datetest, .by_group = TRUE) %>%
slice_head(n = 1) %>%
ungroup() %>%
filter(Change_Type %in% c("StableCN","ProgressiveCN")) %>%
select(Change_Type, all_of(bioimpedance_vars)) %>%
mutate(across(-Change_Type, clean_numeric))
# ============================
# 2) Normality helper functions
# ============================
# Shapiro–Wilk by group, returning results and list of variables flagged non-normal
normality_by_group <- function(df, group_var, vars) {
shapiro_df <- df %>%
select({{ group_var }}, all_of(vars)) %>%
pivot_longer(-{{ group_var }}, names_to = "variable", values_to = "value") %>%
group_by({{ group_var }}, variable) %>%
filter(!is.na(value)) %>%
shapiro_test(value) %>%
ungroup()
non_normal <- shapiro_df %>%
mutate(non_normal = p < 0.05) %>%
group_by(variable) %>%
summarise(any_non_normal = any(non_normal), .groups = "drop") %>%
filter(any_non_normal) %>%
pull(variable)
list(shapiro = shapiro_df, non_normal = non_normal)
}
# Q–Q plot generator (one PDF per set)
qqplot_faceted_to_pdf <- function(df, group_var, vars, pdf_path) {
dir.create(dirname(pdf_path), showWarnings = FALSE, recursive = TRUE)
grDevices::pdf(pdf_path, width = 8.5, height = 11)
for (v in vars) {
p <- ggqqplot(df, x = v, facet.by = rlang::as_name(rlang::ensym(group_var)),
title = paste0("Q-Q plot of ", v, " by ", rlang::as_name(rlang::ensym(group_var))))
print(p)
}
grDevices::dev.off()
}
# ============================
# 3) Run normality diagnostics
# ============================
# Table 1 variables
norm_tbl1 <- normality_by_group(df_long.analysis.baseline, Change_Type, setdiff(vars_tbl1, "EDUYR"))
# ============================
# 0) Libraries & helpers
# ============================
# Normality checks (Shapiro), Q-Q plots, summary tables, export
library(dplyr)
library(tidyr)
library(purrr)
library(readr)
library(rstatix)     # shapiro_test
library(ggpubr)      # ggqqplot
library(gtsummary)   # tbl_summary + add_p
library(flextable)   # as_flex_table
library(officer)     # save_as_docx
library(stringr)
# Helper: clean numeric safely from character/factor
clean_numeric <- function(x) {
if (is.numeric(x)) return(x)
x <- as.character(x)
x <- trimws(x)
x[x == ""] <- NA
suppressWarnings(readr::parse_number(x))
}
# Assert data existence (df_long.analysis built earlier in your pipeline)
stopifnot(exists("df_long.analysis"))
# ============================
# 1) Build baseline datasets
# ============================
# Table 1 variables (clinical/psychometric)
vars_tbl1 <- c("AGE","gds","kdsq","sysbp","diabp","bmr","MMSE","EDUYR")
df_long.analysis.baseline <- df_long.analysis %>%
group_by(USUBJID) %>%
arrange(datetest, .by_group = TRUE) %>%
slice_head(n = 1) %>%
ungroup() %>%
filter(Change_Type %in% c("StableCN","ProgressiveCN")) %>%
select(Change_Type, all_of(vars_tbl1)) %>%
mutate(across(-Change_Type, clean_numeric))
stopifnot(is.numeric(df_long.analysis.baseline$MMSE))
# Bioimpedance variables
bioimpedance_vars <- c(
"bmi","ac","whr","pbcm","pbf","bmr","tbw_ffm",
"ecw_tcw","ECW_ICW_upper","ECW_ICW_lower",
"Water_Lean_upper","Water_Lean_lower",
"R_upper","R_lower","Xc_upper","Xc_lower",
"PA_upper","PA_lower"
)
df_baseline_bia <- df_long.analysis %>%
group_by(USUBJID) %>%
arrange(datetest, .by_group = TRUE) %>%
slice_head(n = 1) %>%
ungroup() %>%
filter(Change_Type %in% c("StableCN","ProgressiveCN")) %>%
select(Change_Type, all_of(bioimpedance_vars)) %>%
mutate(across(-Change_Type, clean_numeric))
# ============================
# 2) Normality helper functions
# ============================
# Shapiro–Wilk by group, returning results and list of variables flagged non-normal
normality_by_group <- function(df, group_var, vars) {
shapiro_df <- df %>%
select({{ group_var }}, all_of(vars)) %>%
pivot_longer(-{{ group_var }}, names_to = "variable", values_to = "value") %>%
group_by({{ group_var }}, variable) %>%
filter(!is.na(value)) %>%
shapiro_test(value) %>%
ungroup()
non_normal <- shapiro_df %>%
mutate(non_normal = p < 0.05) %>%
group_by(variable) %>%
summarise(any_non_normal = any(non_normal), .groups = "drop") %>%
filter(any_non_normal) %>%
pull(variable)
list(shapiro = shapiro_df, non_normal = non_normal)
}
# Q–Q plot generator (one PDF per set)
qqplot_faceted_to_pdf <- function(df, group_var, vars, pdf_path) {
dir.create(dirname(pdf_path), showWarnings = FALSE, recursive = TRUE)
grDevices::pdf(pdf_path, width = 8.5, height = 11)
for (v in vars) {
p <- ggqqplot(df, x = v, facet.by = rlang::as_name(rlang::ensym(group_var)),
title = paste0("Q-Q plot of ", v, " by ", rlang::as_name(rlang::ensym(group_var))))
print(p)
}
grDevices::dev.off()
}
# ============================
# 3) Run normality diagnostics
# ============================
# Table 1 variables
norm_tbl1 <- normality_by_group(df_long.analysis.baseline, Change_Type, setdiff(vars_tbl1, "EDUYR"))
# ============================================================================
# NORMALITY TESTING AND T-TEST COMPARISON SCRIPT
# For Progressive CN vs Stable CN Bioimpedance Study
# ============================================================================
# --- 1. LOAD REQUIRED PACKAGES ---
library(dplyr)
library(tidyr)
library(gtsummary)
library(flextable)
library(rstatix)      # shapiro_test, wilcox_test
library(ggpubr)       # ggqqplot, ggarrange
library(readr)        # parse_number
library(purrr)        # map, set_names
# --- 2. DEFINE HELPER FUNCTION ---
# Hàm làm sạch và chuyển sang numeric
clean_numeric <- function(x) {
if (is.numeric(x)) return(x)
x <- as.character(x)
x <- trimws(x)
x[x == ""] <- NA
suppressWarnings(readr::parse_number(x))
}
# ============================================================================
# PART A: TABLE 1 - DEMOGRAPHIC AND CLINICAL VARIABLES
# ============================================================================
# --- 3. PREPARE BASELINE DATA FOR TABLE 1 ---
df_long.analysis.baseline <- df_long.analysis %>%
group_by(USUBJID) %>%
arrange(datetest, .by_group = TRUE) %>%
slice_head(n = 1) %>%
ungroup() %>%
filter(Change_Type %in% c("StableCN", "ProgressiveCN")) %>%
select(
Change_Type,
AGE, SEX, EDUYR,
gds, kdsq, sysbp, diabp, visit_count, MMSE,
SNSB_attention:SNSB_frontal
) %>%
mutate(across(-Change_Type, clean_numeric))
# Verify MMSE is numeric
stopifnot(is.numeric(df_long.analysis.baseline$MMSE))
# --- 4. SHAPIRO-WILK NORMALITY TEST FOR TABLE 1 VARIABLES ---
# Define continuous variables to test
vars_tbl1 <- c("AGE", "EDUYR", "gds", "kdsq", "sysbp", "diabp",
"visit_count", "MMSE",
"SNSB_attention", "SNSB_language", "SNSB_visuospatial",
"SNSB_memory", "SNSB_frontal")
# Perform Shapiro-Wilk test by group
shapiro_tbl1 <- df_long.analysis.baseline %>%
select(Change_Type, all_of(vars_tbl1)) %>%
pivot_longer(-Change_Type, names_to = "variable", values_to = "value") %>%
drop_na(value) %>%
group_by(Change_Type, variable) %>%
shapiro_test(value) %>%
ungroup() %>%
arrange(variable, Change_Type)
library(dplyr)
library(gtsummary)
library(readr)   # parse_number để làm sạch numeric an toàn
# Hàm làm sạch numeric an toàn
clean_numeric <- function(x) {
if (is.numeric(x)) return(x)
x <- as.character(x)
x <- trimws(x)
x[x == ""] <- NA
suppressWarnings(readr::parse_number(x))
}
# 1) Lấy baseline: dòng đầu tiên theo thời gian cho mỗi USUBJID
df_long.analysis.baseline <- df_long.analysis %>%
group_by(USUBJID) %>%
arrange(datetest, .by_group = TRUE) %>%   # sắp xếp theo ngày khám trong từng người
slice_head(n = 1) %>%                     # lấy đúng 1 dòng baseline/đối tượng
ungroup() %>%
filter(Change_Type %in% c("StableCN", "ProgressiveCN")) %>%
# 2) Chỉ giữ các biến yêu cầu cho Table 1 (không đưa cột Date vào)
select(
Change_Type,
AGE:EDUYR,
gds, kdsq, sysbp, diabp, visit_count, MMSE,
SNSB_attention:SNSB_frontal
) %>%
# 3) Chuẩn hóa kiểu dữ liệu: chỉ các cột khác Change_Type được làm sạch numeric
mutate(across(-Change_Type, clean_numeric))
# (tuỳ chọn) xác nhận MMSE là numeric
stopifnot(is.numeric(df_long.analysis.baseline$MMSE))
# 4) Tạo Table 1: hiển thị mean (sd) cho biến liên tục, ép MMSE là continuous
tbl_summary_obj <- df_long.analysis.baseline %>%
tbl_summary(
by = Change_Type,
type = list(
MMSE ~ "continuous"                 # đảm bảo MMSE hiển thị như biến liên tục
),
statistic = list(
all_continuous() ~ "{mean} ({sd})",
all_categorical() ~ "{n} / {N} ({p}%)"
),
digits = all_continuous() ~ 2,
missing_text = "(Missing)"
) %>%
add_p(
test = list(
all_continuous() ~ "t.test",
all_categorical() ~ "chisq.test"
),
test.args = all_tests("t.test") ~ list(var.equal = FALSE)  # Welch's t-test
) %>%
bold_labels() %>%
bold_p(0.05)
# 5) Xuất bảng
tbl_summary_obj %>% as_flex_table()
library(dplyr)
library(gtsummary)
library(readr)   # parse_number để làm sạch numeric an toàn
# Hàm làm sạch numeric an toàn
clean_numeric <- function(x) {
if (is.numeric(x)) return(x)
x <- as.character(x)
x <- trimws(x)
x[x == ""] <- NA
suppressWarnings(readr::parse_number(x))
}
# 1) Lấy baseline: dòng đầu tiên theo thời gian cho mỗi USUBJID
df_long.analysis.baseline <- df_long.analysis %>%
group_by(USUBJID) %>%
arrange(datetest, .by_group = TRUE) %>%   # sắp xếp theo ngày khám trong từng người
slice_head(n = 1) %>%                     # lấy đúng 1 dòng baseline/đối tượng
ungroup() %>%
filter(Change_Type %in% c("StableCN", "ProgressiveCN")) %>%
# 2) Chỉ giữ các biến yêu cầu cho Table 1 (không đưa cột Date vào)
select(
Change_Type,
AGE:EDUYR,
gds, kdsq, sysbp, diabp, visit_count, MMSE,
SNSB_attention:SNSB_frontal
) %>%
# 3) Chuẩn hóa kiểu dữ liệu: chỉ các cột khác Change_Type được làm sạch numeric
mutate(across(-Change_Type, clean_numeric))
# (tuỳ chọn) xác nhận MMSE là numeric
stopifnot(is.numeric(df_long.analysis.baseline$MMSE))
# Packages
library(dplyr)
library(tidyr)
library(rstatix)   # shapiro_test, wilcox_test helpers
library(ggpubr)    # qq plot
# 1) Chọn biến cần kiểm tra ở Table 1
vars_tbl1 <- c("AGE","gds","kdsq","sysbp","diabp","bmr","MMSE")
# 2) Shapiro–Wilk theo nhóm cho Table 1
shapiro_tbl1 <- df_long.analysis.baseline %>%
select(Change_Type, all_of(vars_tbl1)) %>%
pivot_longer(-Change_Type, names_to = "variable", values_to = "value") %>%
group_by(Change_Type, variable) %>%
shapiro_test(value) %>%      # trả về W và p
ungroup()
